
build/ubersaw.elf:     file format elf32-littlearm


Disassembly of section .text:

20000048 <_text_start>:
  (void)api;
}

__attribute__((weak))
void _hook_cycle(const user_osc_param_t * const params, int32_t *yn, const uint32_t frames)
{
20000048:	4770      	bx	lr

2000004a <_hook_mute>:
  (void)params;
}

__attribute__((weak))
void _hook_mute(const user_osc_param_t * const params)
{
2000004a:	4770      	bx	lr

2000004c <_hook_value>:
  (void)params;
}

__attribute__((weak))
void _hook_value(uint16_t value)
{
2000004c:	4770      	bx	lr
  (void)value;
}

__attribute__((weak))
void _hook_param(uint16_t index, uint16_t value)
{
2000004e:	4770      	bx	lr
20000050:	4770      	bx	lr
20000052:	4770      	bx	lr
  _hook_init(platform, api);
}

__attribute__((weak))
void _hook_init(uint32_t platform, uint32_t api)
{
20000054:	4770      	bx	lr

20000056 <_entry>:
 * @{
 */

__attribute__((used))
void _entry(uint32_t platform, uint32_t api)
{
20000056:	4b10      	ldr	r3, [pc, #64]	; (20000098 <_entry+0x42>)
20000058:	4a10      	ldr	r2, [pc, #64]	; (2000009c <_entry+0x46>)
2000005a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
2000005e:	4688      	mov	r8, r1
20000060:	4607      	mov	r7, r0
  // Ensure zero-clear BSS segment
  uint8_t * __restrict bss_p = (uint8_t *)&_bss_start;
  const uint8_t * const bss_e = (uint8_t *)&_bss_end;

  for (; bss_p != bss_e;)
    *(bss_p++) = 0;
20000062:	2100      	movs	r1, #0
{
  // Ensure zero-clear BSS segment
  uint8_t * __restrict bss_p = (uint8_t *)&_bss_start;
  const uint8_t * const bss_e = (uint8_t *)&_bss_end;

  for (; bss_p != bss_e;)
20000064:	4293      	cmp	r3, r2
20000066:	d002      	beq.n	2000006e <_entry+0x18>
    *(bss_p++) = 0;
20000068:	f803 1f01 	strb.w	r1, [r3, #1]!
2000006c:	e7fa      	b.n	20000064 <_entry+0xe>
2000006e:	4b0c      	ldr	r3, [pc, #48]	; (200000a0 <_entry+0x4a>)
20000070:	4c0c      	ldr	r4, [pc, #48]	; (200000a4 <_entry+0x4e>)
20000072:	1ae4      	subs	r4, r4, r3
20000074:	10a4      	asrs	r4, r4, #2

  // Call constructors if any.  
  const size_t count = __init_array_end - __init_array_start;
  for (size_t i = 0; i<count; ++i) {
20000076:	2500      	movs	r5, #0
20000078:	461e      	mov	r6, r3
2000007a:	42a5      	cmp	r5, r4
2000007c:	d005      	beq.n	2000008a <_entry+0x34>
    __init_fptr init_p = (__init_fptr)__init_array_start[i];
2000007e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
    if (init_p != NULL)
20000082:	b103      	cbz	r3, 20000086 <_entry+0x30>
      init_p();
20000084:	4798      	blx	r3
  for (; bss_p != bss_e;)
    *(bss_p++) = 0;

  // Call constructors if any.  
  const size_t count = __init_array_end - __init_array_start;
  for (size_t i = 0; i<count; ++i) {
20000086:	3501      	adds	r5, #1
20000088:	e7f7      	b.n	2000007a <_entry+0x24>
    if (init_p != NULL)
      init_p();
  }
  
  // Call user initialization
  _hook_init(platform, api);
2000008a:	4641      	mov	r1, r8
2000008c:	4638      	mov	r0, r7
2000008e:	f000 f80b 	bl	200000a8 <_hook_init>
20000092:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
20000096:	bf00      	nop
20000098:	20000a87 	.word	0x20000a87
2000009c:	20000af7 	.word	0x20000af7
200000a0:	20000040 	.word	0x20000040
200000a4:	20000044 	.word	0x20000044

200000a8 <_hook_init>:
# define AMP_CORRECTION 1.f / (NUM_OSC - 1)

// Create UberSaw object
static UberSaw ubersaw;

void OSC_INIT(uint32_t platform, uint32_t api) {
200000a8:	4770      	bx	lr

200000aa <_hook_cycle>:
	(void)platform;
	(void)api;
}

void OSC_CYCLE(const user_osc_param_t *const params, int32_t *yn, const uint32_t frames){
200000aa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	// Get the current note being played.
	
	// =========================================================
	
	uint8_t note = params->pitch>>8;
200000ae:	8886      	ldrh	r6, [r0, #4]
		
		// Get current flag.
		
		// =========================================================
		
		const uint32_t flags = s.flags; 
200000b0:	4cac      	ldr	r4, [pc, #688]	; (20000364 <_hook_cycle+0x2ba>)
	
	// Get the current note being played.
	
	// =========================================================
	
	uint8_t note = params->pitch>>8;
200000b2:	1236      	asrs	r6, r6, #8
void OSC_INIT(uint32_t platform, uint32_t api) {
	(void)platform;
	(void)api;
}

void OSC_CYCLE(const user_osc_param_t *const params, int32_t *yn, const uint32_t frames){
200000b4:	ed2d 8b10 	vpush	{d8-d15}
	
	// Get the current note being played.
	
	// =========================================================
	
	uint8_t note = params->pitch>>8;
200000b8:	b2f5      	uxtb	r5, r6
   * @return     Corresponding band-limited wave fractional index in [0-6].
   */
  float _osc_bl_saw_idx(float note);

  __fast_inline float osc_bl_saw_idx(float note) {
    return _osc_bl_saw_idx(note);
200000ba:	ee07 5a90 	vmov	s15, r5
void OSC_INIT(uint32_t platform, uint32_t api) {
	(void)platform;
	(void)api;
}

void OSC_CYCLE(const user_osc_param_t *const params, int32_t *yn, const uint32_t frames){
200000be:	b08a      	sub	sp, #40	; 0x28
200000c0:	eeb8 0a67 	vcvt.f32.u32	s0, s15
200000c4:	4690      	mov	r8, r2
200000c6:	4681      	mov	r9, r0
200000c8:	460f      	mov	r7, r1
200000ca:	f000 fcd9 	bl	20000a80 <___osc_bl_saw_idx_veneer>
		
		// Get current flag.
		
		// =========================================================
		
		const uint32_t flags = s.flags; 
200000ce:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
		
		// Reset s.flags.
		
		// =========================================================
		
		s.flags = UberSaw::flags_none;
200000d2:	461a      	mov	r2, r3
200000d4:	f36f 0201 	bfc	r2, #0, #2
		
		// Check if action required.
		
		// =========================================================
		
		if(flags & UberSaw::flag_detune) {
200000d8:	079b      	lsls	r3, r3, #30
200000da:	eeb0 8a40 	vmov.f32	s16, s0
		
		// Reset s.flags.
		
		// =========================================================
		
		s.flags = UberSaw::flags_none;
200000de:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
		
		// Check if action required.
		
		// =========================================================
		
		if(flags & UberSaw::flag_detune) {
200000e2:	d502      	bpl.n	200000ea <_hook_cycle+0x40>
			ubersaw.updateDetune();
200000e4:	4620      	mov	r0, r4
200000e6:	f000 fc01 	bl	200008ec <_ZN7UberSaw12updateDetuneEv>
		
		// Update the pitches.
		
		// =========================================================
		
		ubersaw.updatePitch(osc_w0f_for_note(note, params->pitch & 0xFF));
200000ea:	f899 3004 	ldrb.w	r3, [r9, #4]
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
200000ee:	4a9e      	ldr	r2, [pc, #632]	; (20000368 <_hook_cycle+0x2be>)

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
200000f0:	eddf 6a9e 	vldr	s13, [pc, #632]	; 2000036c <_hook_cycle+0x2c2>
			float detune_down = 1.f - detune_amount;
		
			float detune_up = 1.f + detune_amount;
			
			// Detune side oscs and add phase drift
			state.w0[i] = (w0 * detune_down) + (drift * SIDE_DRIFT);
200000f4:	ed9f 6a9e 	vldr	s12, [pc, #632]	; 20000370 <_hook_cycle+0x2c6>
	inline void updatePitch(float w0) {
		// Get phase drift from A knob
		const float drift = params.shiftshape;
		
		// Get detune curve value (provided by update detune)
		const float detune = params.detune;
200000f8:	ed94 5a18 	vldr	s10, [r4, #96]	; 0x60
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
200000fc:	3501      	adds	r5, #1
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
200000fe:	2e96      	cmp	r6, #150	; 0x96
20000100:	ee07 3a90 	vmov	s15, r3
   * @param note Note in [0-151] range, mod in [0-255] range.
   * @return     Corresponding 0-1 phase increment in floating point.
   */
  __fast_inline float osc_w0f_for_note(uint8_t note, uint8_t mod) {    
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
20000104:	b2eb      	uxtb	r3, r5
   *
   * @param note Note in [0-151] range.
   * @return     Corresponding Hertz value.
   */
  __fast_inline float osc_notehzf(uint8_t note) {
    return midi_to_hz_lut_f[clipmaxu32(note,k_midi_to_hz_size-1)];
20000106:	bfc8      	it	gt
20000108:	2697      	movgt	r6, #151	; 0x97
2000010a:	2b96      	cmp	r3, #150	; 0x96
2000010c:	bf88      	it	hi
2000010e:	2397      	movhi	r3, #151	; 0x97
20000110:	eef8 7ae7 	vcvt.f32.s32	s15, s15
20000114:	eb02 0686 	add.w	r6, r2, r6, lsl #2
20000118:	eb02 0383 	add.w	r3, r2, r3, lsl #2
2000011c:	ed96 7a00 	vldr	s14, [r6]
20000120:	4e90      	ldr	r6, [pc, #576]	; (20000364 <_hook_cycle+0x2ba>)
20000122:	ee67 7aa6 	vmul.f32	s15, s15, s13
20000126:	edd3 6a00 	vldr	s13, [r3]
2000012a:	ee76 6ac7 	vsub.f32	s13, s13, s14
2000012e:	f106 0218 	add.w	r2, r6, #24
20000132:	eea7 7aa6 	vfma.f32	s14, s15, s13
			float detune_down = 1.f - detune_amount;
		
			float detune_up = 1.f + detune_amount;
			
			// Detune side oscs and add phase drift
			state.w0[i] = (w0 * detune_down) + (drift * SIDE_DRIFT);
20000136:	4633      	mov	r3, r6
		
		// Set pitch of central oscillator
		state.w0[0] = w0;
		
		// Set pitches of side oscillators
		float step = 1.f;
20000138:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
2000013c:	eef0 7a47 	vmov.f32	s15, s14

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
20000140:	ed9f 7a8c 	vldr	s14, [pc, #560]	; 20000374 <_hook_cycle+0x2ca>
20000144:	eef4 7ac7 	vcmpe.f32	s15, s14
20000148:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000014c:	bfb8      	it	lt
2000014e:	eeb0 7a67 	vmovlt.f32	s14, s15
    const float f0 = osc_notehzf(note);
    const float f1 = osc_notehzf(note+1);
    
    const float f = clipmaxf(linintf(mod * k_note_mod_fscale, f0, f1), k_note_max_hz);

    return f * k_samplerate_recipf;
20000152:	eddf 7a89 	vldr	s15, [pc, #548]	; 20000378 <_hook_cycle+0x2ce>
20000156:	ee67 7a27 	vmul.f32	s15, s14, s15
		params = Params();
	}
  
	inline void updatePitch(float w0) {
		// Get phase drift from A knob
		const float drift = params.shiftshape;
2000015a:	ed94 7a1b 	vldr	s14, [r4, #108]	; 0x6c
		
		// Get detune curve value (provided by update detune)
		const float detune = params.detune;
		
		// Set pitch of central oscillator
		state.w0[0] = w0;
2000015e:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			float detune_down = 1.f - detune_amount;
		
			float detune_up = 1.f + detune_amount;
			
			// Detune side oscs and add phase drift
			state.w0[i] = (w0 * detune_down) + (drift * SIDE_DRIFT);
20000162:	ee27 6a06 	vmul.f32	s12, s14, s12
20000166:	eef0 4a66 	vmov.f32	s9, s13
		
		// Set pitches of side oscillators
		float step = 1.f;
		for(int i = 1; i < NUM_OSC; i += 2) {
			// Calculate detune amounts (Alex Shore's method)
			float detune_amount = (step / 3.f) * detune;
2000016a:	eeb0 3a08 	vmov.f32	s6, #8	; 0x40400000  3.0
			float detune_down = 1.f - detune_amount;
		
			float detune_up = 1.f + detune_amount;
			
			// Detune side oscs and add phase drift
			state.w0[i] = (w0 * detune_down) + (drift * SIDE_DRIFT);
2000016e:	eef1 3a45 	vneg.f32	s7, s10
		
		// Set pitches of side oscillators
		float step = 1.f;
		for(int i = 1; i < NUM_OSC; i += 2) {
			// Calculate detune amounts (Alex Shore's method)
			float detune_amount = (step / 3.f) * detune;
20000172:	eec6 5a83 	vdiv.f32	s11, s13, s6
20000176:	3308      	adds	r3, #8
			float detune_down = 1.f - detune_amount;
		
			float detune_up = 1.f + detune_amount;
			
			// Detune side oscs and add phase drift
			state.w0[i] = (w0 * detune_down) + (drift * SIDE_DRIFT);
20000178:	eeb0 4a64 	vmov.f32	s8, s9
2000017c:	eea3 4aa5 	vfma.f32	s8, s7, s11
20000180:	eef0 2a46 	vmov.f32	s5, s12
20000184:	eee7 2a84 	vfma.f32	s5, s15, s8
			
			state.w0[i + 1] = (w0 * detune_up) + (drift * SIDE_DRIFT);
20000188:	eeb0 4a64 	vmov.f32	s8, s9
2000018c:	eea5 4a25 	vfma.f32	s8, s10, s11
			float detune_down = 1.f - detune_amount;
		
			float detune_up = 1.f + detune_amount;
			
			// Detune side oscs and add phase drift
			state.w0[i] = (w0 * detune_down) + (drift * SIDE_DRIFT);
20000190:	edc3 2a08 	vstr	s5, [r3, #32]
			
			state.w0[i + 1] = (w0 * detune_up) + (drift * SIDE_DRIFT);
20000194:	eef0 5a44 	vmov.f32	s11, s8
20000198:	eeb0 4a46 	vmov.f32	s8, s12
2000019c:	eea7 4aa5 	vfma.f32	s8, s15, s11
			step++;
200001a0:	ee76 6aa4 	vadd.f32	s13, s13, s9
			float detune_up = 1.f + detune_amount;
			
			// Detune side oscs and add phase drift
			state.w0[i] = (w0 * detune_down) + (drift * SIDE_DRIFT);
			
			state.w0[i + 1] = (w0 * detune_up) + (drift * SIDE_DRIFT);
200001a4:	ed83 4a09 	vstr	s8, [r3, #36]	; 0x24
		// Set pitch of central oscillator
		state.w0[0] = w0;
		
		// Set pitches of side oscillators
		float step = 1.f;
		for(int i = 1; i < NUM_OSC; i += 2) {
200001a8:	429a      	cmp	r2, r3
200001aa:	d1e2      	bne.n	20000172 <_hook_cycle+0xc8>
			state.w0[i + 1] = (w0 * detune_up) + (drift * SIDE_DRIFT);
			step++;
		}
		
		// Make superwave an octave higher and add a phase drift
		state.w0super = (2.f * w0) + (drift * SUB_DRIFT);
200001ac:	ed9f 5a73 	vldr	s10, [pc, #460]	; 2000037c <_hook_cycle+0x2d2>
200001b0:	f8df e1f0 	ldr.w	lr, [pc, #496]	; 200003a4 <_hook_cycle+0x2fa>
200001b4:	ee27 5a05 	vmul.f32	s10, s14, s10
	
		// Make subwave an octave lower and add a phase drift
		state.w0sub = (0.5f * w0) + (drift * SUB_DRIFT);
200001b8:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
			state.w0[i + 1] = (w0 * detune_up) + (drift * SIDE_DRIFT);
			step++;
		}
		
		// Make superwave an octave higher and add a phase drift
		state.w0super = (2.f * w0) + (drift * SUB_DRIFT);
200001bc:	eeb0 2a45 	vmov.f32	s4, s10
200001c0:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
200001c4:	eea7 2a87 	vfma.f32	s4, s15, s14
200001c8:	a903      	add	r1, sp, #12
		
		// Get the current LFO value.
		
		// =========================================================
		
		s.lfo = q31_to_f32(params->shape_lfo);
200001ca:	460a      	mov	r2, r1
	
		// Make subwave an octave lower and add a phase drift
		state.w0sub = (0.5f * w0) + (drift * SUB_DRIFT);
200001cc:	eea7 5aa3 	vfma.f32	s10, s15, s7
200001d0:	f1ae 031c 	sub.w	r3, lr, #28
200001d4:	edd9 7a00 	vldr	s15, [r9]
			state.w0[i + 1] = (w0 * detune_up) + (drift * SIDE_DRIFT);
			step++;
		}
		
		// Make superwave an octave higher and add a phase drift
		state.w0super = (2.f * w0) + (drift * SUB_DRIFT);
200001d8:	ed84 2a10 	vstr	s4, [r4, #64]	; 0x40
200001dc:	eefa 7ae0 	vcvt.f32.s32	s15, s15, #31
	
		// Make subwave an octave lower and add a phase drift
		state.w0sub = (0.5f * w0) + (drift * SUB_DRIFT);
200001e0:	ed84 5a11 	vstr	s10, [r4, #68]	; 0x44
200001e4:	edc4 7a12 	vstr	s15, [r4, #72]	; 0x48
	
	// =========================================================
	
	float phi[NUM_OSC];
	for(int i = 0; i < NUM_OSC; i++) {
		phi[i] = s.phi[i];
200001e8:	f853 0b04 	ldr.w	r0, [r3], #4
200001ec:	f842 0b04 	str.w	r0, [r2], #4
	// Create local copies of the state object fields.
	
	// =========================================================
	
	float phi[NUM_OSC];
	for(int i = 0; i < NUM_OSC; i++) {
200001f0:	459e      	cmp	lr, r3
200001f2:	d1f9      	bne.n	200001e8 <_hook_cycle+0x13e>

	// Update Final LFO state
	
	// =========================================================
	
	float lfoz = s.lfoz;
200001f4:	ed94 4a13 	vldr	s8, [r4, #76]	; 0x4c
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
200001f8:	4861      	ldr	r0, [pc, #388]	; (20000380 <_hook_cycle+0x2d6>)
   * @return        Wave sample.
   */
  __fast_inline float osc_bl2_sawf(float x, float idx) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200001fa:	eddf 0a62 	vldr	s1, [pc, #392]	; 20000384 <_hook_cycle+0x2da>
	
	float phi[NUM_OSC];
	for(int i = 0; i < NUM_OSC; i++) {
		phi[i] = s.phi[i];
	}
	float phisub = s.phisub;
200001fe:	edd4 5a08 	vldr	s11, [r4, #32]
	float phisuper = s.phisuper;
20000202:	ed94 6a07 	vldr	s12, [r4, #28]
	
	// Create local copies of parameter object fields.
	
	// =========================================================
	
	const float submix = p.submix;
20000206:	edd4 1a15 	vldr	s3, [r4, #84]	; 0x54
	const float supermix = p.supermix;
2000020a:	ed94 1a16 	vldr	s2, [r4, #88]	; 0x58
	const float ringmix = p.ringmix;
2000020e:	ed94 3a17 	vldr	s6, [r4, #92]	; 0x5c
		
		// Get mix control value, range [0-1].
		
		// =========================================================
		
		const float wavemix = clipminmaxf(0.00f, p.shape+lfoz, 1.f);
20000212:	edd4 8a1a 	vldr	s17, [r4, #104]	; 0x68
20000216:	ed9f 9a5c 	vldr	s18, [pc, #368]	; 20000388 <_hook_cycle+0x2de>
		
		// Calculate primary and secondary mix values (Adam Szabo's method).
		
		// =========================================================
		
		float primary_mix = (-0.55366 * wavemix) + 0.99785;
2000021a:	eddf 9a5c 	vldr	s19, [pc, #368]	; 2000038c <_hook_cycle+0x2e2>
2000021e:	ed9f aa5c 	vldr	s20, [pc, #368]	; 20000390 <_hook_cycle+0x2e6>
		float secondary_mix = (-0.73764 * wavemix * wavemix) + (1.2841 * wavemix) + 0.44372;
20000222:	eddf aa5c 	vldr	s21, [pc, #368]	; 20000394 <_hook_cycle+0x2ea>
20000226:	ed9f ba5c 	vldr	s22, [pc, #368]	; 20000398 <_hook_cycle+0x2ee>
2000022a:	eddf ba5c 	vldr	s23, [pc, #368]	; 2000039c <_hook_cycle+0x2f2>
		float sig = 0.f;
		for(int i = 1; i < NUM_OSC; i++) {
			sig += secondary_mix * osc_bl2_sawf(phi[i], index);
		}
		sig *= AMP_CORRECTION;
		main_sig += sig;
2000022e:	ed9f ca5c 	vldr	s24, [pc, #368]	; 200003a0 <_hook_cycle+0x2f6>
	// =========================================================
	
	// Get LFO increment per frame
	
	// =========================================================
	const float lfo_inc = (s.lfo - lfoz) / frames;
20000232:	ee07 8a10 	vmov	s14, r8
20000236:	ee77 7ac4 	vsub.f32	s15, s15, s8
2000023a:	eeb8 7a47 	vcvt.f32.u32	s14, s14
	
	// Prepare to load buffer.
	
	// =========================================================
	q31_t *__restrict y = (q31_t*)yn; // y is buffer start position.
	const q31_t *y_e = y + frames; // y_e is buffer end position.
2000023e:	eb07 0288 	add.w	r2, r7, r8, lsl #2
	// =========================================================
	
	// Get LFO increment per frame
	
	// =========================================================
	const float lfo_inc = (s.lfo - lfoz) / frames;
20000242:	ee87 0a87 	vdiv.f32	s0, s15, s14
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
20000246:	eefc 7ac8 	vcvt.u32.f32	s15, s16
2000024a:	eef0 2a60 	vmov.f32	s5, s1
2000024e:	edcd 7a01 	vstr	s15, [sp, #4]
20000252:	f8bd 3004 	ldrh.w	r3, [sp, #4]
20000256:	eb03 13c3 	add.w	r3, r3, r3, lsl #7
2000025a:	eb00 0383 	add.w	r3, r0, r3, lsl #2
    const float fr = x0f - x0p;
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);

    wt += k_wt_saw_lut_size;
2000025e:	f503 7501 	add.w	r5, r3, #516	; 0x204
	// =========================================================
	
	// Load the buffer.
	
	// =========================================================
	for (; y != y_e; ) {
20000262:	4297      	cmp	r7, r2
20000264:	f000 81de 	beq.w	20000624 <_hook_cycle+0x57a>
		
		// Get mix control value, range [0-1].
		
		// =========================================================
		
		const float wavemix = clipminmaxf(0.00f, p.shape+lfoz, 1.f);
20000268:	ee34 7a28 	vadd.f32	s14, s8, s17
2000026c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
20000270:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
20000274:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000278:	bfb8      	it	lt
2000027a:	eeb0 7a49 	vmovlt.f32	s14, s18
2000027e:	ee77 6a64 	vsub.f32	s13, s14, s9
		*
		*/ 
		
		// =========================================================
		
		float main_sig = primary_mix * osc_bl2_sawf(phi[0], index);
20000282:	eddd da03 	vldr	s27, [sp, #12]
20000286:	eef5 6a40 	vcmp.f32	s13, #0.0
2000028a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
2000028e:	bfa8      	it	ge
20000290:	eeb0 7a67 	vmovge.f32	s14, s15
		// Calculate primary and secondary mix values (Adam Szabo's method).
		
		// =========================================================
		
		float primary_mix = (-0.55366 * wavemix) + 0.99785;
		float secondary_mix = (-0.73764 * wavemix * wavemix) + (1.2841 * wavemix) + 0.44372;
20000294:	ee27 da2a 	vmul.f32	s26, s14, s21
20000298:	ee67 6a0b 	vmul.f32	s13, s14, s22
		
		// Calculate primary and secondary mix values (Adam Szabo's method).
		
		// =========================================================
		
		float primary_mix = (-0.55366 * wavemix) + 0.99785;
2000029c:	eef0 ca4a 	vmov.f32	s25, s20
		float secondary_mix = (-0.73764 * wavemix * wavemix) + (1.2841 * wavemix) + 0.44372;
200002a0:	eeed 6a07 	vfma.f32	s13, s26, s14
200002a4:	f10d 0910 	add.w	r9, sp, #16
   * @return        Wave sample.
   */
  __fast_inline float osc_bl2_sawf(float x, float idx) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200002a8:	eebc daed 	vcvt.u32.f32	s26, s27
		
		// Calculate primary and secondary mix values (Adam Szabo's method).
		
		// =========================================================
		
		float primary_mix = (-0.55366 * wavemix) + 0.99785;
200002ac:	eee7 ca29 	vfma.f32	s25, s14, s19
200002b0:	eeb8 da4d 	vcvt.f32.u32	s26, s26
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);

    wt += k_wt_saw_lut_size;
    const float y1 = sign * linintf(fr, wt[x0], wt[x1]);
    
    return linintf((idx - (uint8_t)idx), y0, y1);
200002b4:	eebc eac8 	vcvt.u32.f32	s28, s16
   * @return        Wave sample.
   */
  __fast_inline float osc_bl2_sawf(float x, float idx) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200002b8:	ee3d dacd 	vsub.f32	s26, s27, s26
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);

    wt += k_wt_saw_lut_size;
    const float y1 = sign * linintf(fr, wt[x0], wt[x1]);
    
    return linintf((idx - (uint8_t)idx), y0, y1);
200002bc:	ed8d ea01 	vstr	s28, [sp, #4]
   * @return        Wave sample.
   */
  __fast_inline float osc_bl2_sawf(float x, float idx) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200002c0:	ee2d da20 	vmul.f32	s26, s26, s1
		float secondary_mix = (-0.73764 * wavemix * wavemix) + (1.2841 * wavemix) + 0.44372;
200002c4:	ee76 6aab 	vadd.f32	s13, s13, s23
    const uint32_t x0p = (uint32_t)x0f;
200002c8:	eebc 7acd 	vcvt.u32.f32	s14, s26
200002cc:	ee17 8a10 	vmov	r8, s14
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
200002d0:	f1b8 0f7f 	cmp.w	r8, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
200002d4:	bf8b      	itete	hi
200002d6:	f008 007f 	andhi.w	r0, r8, #127	; 0x7f
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200002da:	eeb0 7a67 	vmovls.f32	s14, s15
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
200002de:	f1c0 0c80 	rsbhi	ip, r0, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200002e2:	46c4      	movls	ip, r8
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
200002e4:	ee07 8a90 	vmov	s15, r8
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200002e8:	bf98      	it	ls
200002ea:	f108 0001 	addls.w	r0, r8, #1
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);
200002ee:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
200002f2:	bf88      	it	hi
200002f4:	f1c0 007f 	rsbhi	r0, r0, #127	; 0x7f
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);
200002f8:	eb03 080c 	add.w	r8, r3, ip
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
200002fc:	eef8 7a67 	vcvt.f32.u32	s15, s15
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);
20000300:	ea4f 0080 	mov.w	r0, r0, lsl #2
20000304:	edd8 da00 	vldr	s27, [r8]
20000308:	eb03 0800 	add.w	r8, r3, r0
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
2000030c:	ee3d da67 	vsub.f32	s26, s26, s15

/** Linear interpolation
 */
static inline __attribute__((optimize("Ofast"), always_inline))
float linintf(const float fr, const float x0, const float x1) {
  return x0 + fr * (x1 - x0);
20000310:	edd8 7a00 	vldr	s15, [r8]
20000314:	ee77 7aed 	vsub.f32	s15, s15, s27
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);

    wt += k_wt_saw_lut_size;
    const float y1 = sign * linintf(fr, wt[x0], wt[x1]);
20000318:	44ac      	add	ip, r5
2000031a:	4428      	add	r0, r5
2000031c:	eeed da27 	vfma.f32	s27, s26, s15
		*
		*/ 
		
		// =========================================================
		
		float main_sig = primary_mix * osc_bl2_sawf(phi[0], index);
20000320:	ed90 ea00 	vldr	s28, [r0]
20000324:	eddc 7a00 	vldr	s15, [ip]
    
    return linintf((idx - (uint8_t)idx), y0, y1);
20000328:	f89d c004 	ldrb.w	ip, [sp, #4]
2000032c:	ee3e ea67 	vsub.f32	s28, s28, s15
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
20000330:	bf88      	it	hi
20000332:	eebf 7a00 	vmovhi.f32	s14, #240	; 0xbf800000 -1.0
20000336:	eeed 7a0e 	vfma.f32	s15, s26, s28
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);

    wt += k_wt_saw_lut_size;
    const float y1 = sign * linintf(fr, wt[x0], wt[x1]);
    
    return linintf((idx - (uint8_t)idx), y0, y1);
2000033a:	ee0e ca90 	vmov	s29, ip
2000033e:	ee67 7a87 	vmul.f32	s15, s15, s14
20000342:	eef8 eaee 	vcvt.f32.s32	s29, s29
20000346:	eeed 7ac7 	vfms.f32	s15, s27, s14
2000034a:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
2000034e:	ee78 ea6e 	vsub.f32	s29, s16, s29
		/*
		* Test 1: Define separate signal for side osc, sum values
		* and then apply amp correction before adding to main signal
		*/ 
		
		float sig = 0.f;
20000352:	ed9f da0d 	vldr	s26, [pc, #52]	; 20000388 <_hook_cycle+0x2de>
		*
		*/ 
		
		// =========================================================
		
		float main_sig = primary_mix * osc_bl2_sawf(phi[0], index);
20000356:	ee67 7aae 	vmul.f32	s15, s15, s29
2000035a:	eeed 7a87 	vfma.f32	s15, s27, s14
2000035e:	ee67 7aac 	vmul.f32	s15, s15, s25
20000362:	e021      	b.n	200003a8 <_hook_cycle+0x2fe>
20000364:	20000a88 	.word	0x20000a88
20000368:	0800f100 	.word	0x0800f100
2000036c:	3b808081 	.word	0x3b808081
20000370:	36aec33e 	.word	0x36aec33e
20000374:	46b8ff49 	.word	0x46b8ff49
20000378:	37aec33e 	.word	0x37aec33e
2000037c:	3651b717 	.word	0x3651b717
20000380:	08011db8 	.word	0x08011db8
20000384:	43800000 	.word	0x43800000
20000388:	00000000 	.word	0x00000000
2000038c:	bf0dbca9 	.word	0xbf0dbca9
20000390:	3f7f7319 	.word	0x3f7f7319
20000394:	bf3cd5fa 	.word	0xbf3cd5fa
20000398:	3fa45d64 	.word	0x3fa45d64
2000039c:	3ee32f45 	.word	0x3ee32f45
200003a0:	3e2aaaab 	.word	0x3e2aaaab
200003a4:	20000aa4 	.word	0x20000aa4
		* and then apply amp correction before adding to main signal
		*/ 
		
		float sig = 0.f;
		for(int i = 1; i < NUM_OSC; i++) {
			sig += secondary_mix * osc_bl2_sawf(phi[i], index);
200003a8:	ecf9 da01 	vldmia	r9!, {s27}
   * @return        Wave sample.
   */
  __fast_inline float osc_bl2_sawf(float x, float idx) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200003ac:	eefc caed 	vcvt.u32.f32	s25, s27
200003b0:	eef8 ca6c 	vcvt.f32.u32	s25, s25
200003b4:	ee7d caec 	vsub.f32	s25, s27, s25
200003b8:	ee6c caa2 	vmul.f32	s25, s25, s5
    const uint32_t x0p = (uint32_t)x0f;
200003bc:	eebc 7aec 	vcvt.u32.f32	s14, s25
200003c0:	ee17 aa10 	vmov	sl, s14
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
200003c4:	f1ba 0f7f 	cmp.w	sl, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
200003c8:	bf87      	ittee	hi
200003ca:	f00a 007f 	andhi.w	r0, sl, #127	; 0x7f
200003ce:	f1c0 0880 	rsbhi	r8, r0, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
200003d2:	46d0      	movls	r8, sl
200003d4:	f10a 0001 	addls.w	r0, sl, #1
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
200003d8:	bf88      	it	hi
200003da:	f1c0 007f 	rsbhi	r0, r0, #127	; 0x7f
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
200003de:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);
200003e2:	ea4f 0888 	mov.w	r8, r8, lsl #2
200003e6:	eb03 0a08 	add.w	sl, r3, r8
200003ea:	ea4f 0080 	mov.w	r0, r0, lsl #2
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
200003ee:	ee3c eac7 	vsub.f32	s28, s25, s14
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);
200003f2:	edda ca00 	vldr	s25, [sl]
200003f6:	eb03 0a00 	add.w	sl, r3, r0
200003fa:	ed9a 7a00 	vldr	s14, [sl]
200003fe:	ee37 7a6c 	vsub.f32	s14, s14, s25

    wt += k_wt_saw_lut_size;
    const float y1 = sign * linintf(fr, wt[x0], wt[x1]);
20000402:	44a8      	add	r8, r5
20000404:	4428      	add	r0, r5
20000406:	eeee ca07 	vfma.f32	s25, s28, s14
2000040a:	ed90 fa00 	vldr	s30, [r0]
2000040e:	ed98 7a00 	vldr	s14, [r8]
20000412:	ee3f fa47 	vsub.f32	s30, s30, s14
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
20000416:	bf98      	it	ls
20000418:	eef7 da00 	vmovls.f32	s27, #112	; 0x3f800000  1.0
2000041c:	eeae 7a0f 	vfma.f32	s14, s28, s30
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
20000420:	bf88      	it	hi
20000422:	eeff da00 	vmovhi.f32	s27, #240	; 0xbf800000 -1.0
20000426:	ee27 7a2d 	vmul.f32	s14, s14, s27
		* Test 1: Define separate signal for side osc, sum values
		* and then apply amp correction before adding to main signal
		*/ 
		
		float sig = 0.f;
		for(int i = 1; i < NUM_OSC; i++) {
2000042a:	45cc      	cmp	ip, r9
			sig += secondary_mix * osc_bl2_sawf(phi[i], index);
2000042c:	eeac 7aed 	vfms.f32	s14, s25, s27
20000430:	ee27 7a2e 	vmul.f32	s14, s14, s29
20000434:	eeac 7aad 	vfma.f32	s14, s25, s27
20000438:	eea6 da87 	vfma.f32	s26, s13, s14
		* Test 1: Define separate signal for side osc, sum values
		* and then apply amp correction before adding to main signal
		*/ 
		
		float sig = 0.f;
		for(int i = 1; i < NUM_OSC; i++) {
2000043c:	d1b4      	bne.n	200003a8 <_hook_cycle+0x2fe>
   * @return        Wave sample.
   */
  __fast_inline float osc_bl2_sawf(float x, float idx) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
2000043e:	eebc 7ae5 	vcvt.u32.f32	s14, s11
			sig += secondary_mix * osc_bl2_sawf(phi[i], index);
		}
		sig *= AMP_CORRECTION;
		main_sig += sig;
20000442:	eeed 7a0c 	vfma.f32	s15, s26, s24
20000446:	eeb8 7a47 	vcvt.f32.u32	s14, s14
2000044a:	eeff ca00 	vmov.f32	s25, #240	; 0xbf800000 -1.0
2000044e:	ee35 7ac7 	vsub.f32	s14, s11, s14
20000452:	ee27 7a22 	vmul.f32	s14, s14, s5
    const uint32_t x0p = (uint32_t)x0f;
20000456:	eefc 6ac7 	vcvt.u32.f32	s13, s14
2000045a:	ee16 9a90 	vmov	r9, s13
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
2000045e:	f1b9 0f7f 	cmp.w	r9, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
20000462:	bf86      	itte	hi
20000464:	f009 007f 	andhi.w	r0, r9, #127	; 0x7f
20000468:	f1c0 0880 	rsbhi	r8, r0, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
2000046c:	46c8      	movls	r8, r9
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
2000046e:	ee0d 9a10 	vmov	s26, r9
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
20000472:	bf94      	ite	ls
20000474:	f109 0001 	addls.w	r0, r9, #1
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
20000478:	f1c0 007f 	rsbhi	r0, r0, #127	; 0x7f
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);
2000047c:	ea4f 0888 	mov.w	r8, r8, lsl #2
20000480:	eb03 0908 	add.w	r9, r3, r8
20000484:	ea4f 0080 	mov.w	r0, r0, lsl #2
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
20000488:	eeb8 da4d 	vcvt.f32.u32	s26, s26
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);
2000048c:	edd9 da00 	vldr	s27, [r9]
20000490:	eb03 0900 	add.w	r9, r3, r0
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
20000494:	ee37 da4d 	vsub.f32	s26, s14, s26
20000498:	ed99 7a00 	vldr	s14, [r9]
2000049c:	ee37 7a6d 	vsub.f32	s14, s14, s27
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);

    wt += k_wt_saw_lut_size;
    const float y1 = sign * linintf(fr, wt[x0], wt[x1]);
200004a0:	4428      	add	r0, r5
200004a2:	44a8      	add	r8, r5
200004a4:	eeed da07 	vfma.f32	s27, s26, s14
		*
		*/ 
		
		// =========================================================
		
		const float subsig = 0.5f * osc_bl2_sawf(phisub, index);
200004a8:	ed90 ea00 	vldr	s28, [r0]
200004ac:	ed98 7a00 	vldr	s14, [r8]
200004b0:	ee3e ea47 	vsub.f32	s28, s28, s14
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
200004b4:	bf98      	it	ls
200004b6:	eef7 6a00 	vmovls.f32	s13, #112	; 0x3f800000  1.0
200004ba:	eead 7a0e 	vfma.f32	s14, s26, s28
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
200004be:	bf88      	it	hi
200004c0:	eef0 6a6c 	vmovhi.f32	s13, s25
200004c4:	ee27 7a26 	vmul.f32	s14, s14, s13
200004c8:	eead 7ae6 	vfms.f32	s14, s27, s13
200004cc:	ee27 7a2e 	vmul.f32	s14, s14, s29
200004d0:	eead 7aa6 	vfma.f32	s14, s27, s13
		
		// Apply submix, can set as dominant or inaudible.
		
		// =========================================================
		
		main_sig = (1.f - submix) * main_sig + (submix * subsig);
200004d4:	ee74 6ae1 	vsub.f32	s13, s9, s3
		*
		*/ 
		
		// =========================================================
		
		const float subsig = 0.5f * osc_bl2_sawf(phisub, index);
200004d8:	ee27 7a23 	vmul.f32	s14, s14, s7
		
		// Apply submix, can set as dominant or inaudible.
		
		// =========================================================
		
		main_sig = (1.f - submix) * main_sig + (submix * subsig);
200004dc:	ee21 da87 	vmul.f32	s26, s3, s14
200004e0:	eea7 daa6 	vfma.f32	s26, s15, s13
   * @return        Wave sample.
   */
  __fast_inline float osc_bl2_sawf(float x, float idx) {
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
200004e4:	eefc 7ac6 	vcvt.u32.f32	s15, s12
200004e8:	eef8 7a67 	vcvt.f32.u32	s15, s15
200004ec:	ee76 7a67 	vsub.f32	s15, s12, s15
200004f0:	ee67 7aa2 	vmul.f32	s15, s15, s5
    const uint32_t x0p = (uint32_t)x0f;
200004f4:	eefc 6ae7 	vcvt.u32.f32	s13, s15
200004f8:	ee16 9a90 	vmov	r9, s13
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
200004fc:	f1b9 0f7f 	cmp.w	r9, #127	; 0x7f
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
20000500:	bf87      	ittee	hi
20000502:	f009 007f 	andhi.w	r0, r9, #127	; 0x7f
20000506:	f1c0 0880 	rsbhi	r8, r0, #128	; 0x80
    const float p = x - (uint32_t)x;
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
2000050a:	46c8      	movls	r8, r9
2000050c:	f109 0001 	addls.w	r0, r9, #1
    float sign = 1.f;
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
20000510:	bf88      	it	hi
20000512:	f1c0 007f 	rsbhi	r0, r0, #127	; 0x7f
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);
20000516:	ea4f 0888 	mov.w	r8, r8, lsl #2
2000051a:	eb03 0908 	add.w	r9, r3, r8
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
2000051e:	eef8 6a66 	vcvt.f32.u32	s13, s13
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);
20000522:	ea4f 0080 	mov.w	r0, r0, lsl #2
20000526:	edd9 da00 	vldr	s27, [r9]
2000052a:	eb03 0900 	add.w	r9, r3, r0
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
    }
    const float *wt = &wt_saw_lut_f[(uint16_t)idx*k_wt_saw_lut_size];
    const float fr = x0f - x0p;
2000052e:	ee77 7ae6 	vsub.f32	s15, s15, s13
20000532:	edd9 6a00 	vldr	s13, [r9]
20000536:	ee76 6aed 	vsub.f32	s13, s13, s27
    const float y0 = sign * linintf(fr, wt[x0], wt[x1]);

    wt += k_wt_saw_lut_size;
    const float y1 = sign * linintf(fr, wt[x0], wt[x1]);
2000053a:	44a8      	add	r8, r5
2000053c:	4428      	add	r0, r5
2000053e:	eee7 daa6 	vfma.f32	s27, s15, s13
		*
		*/ 
		
		// =========================================================
		
		const float supersig = 0.5f * osc_bl2_sawf(phisuper, index);
20000542:	ed90 fa00 	vldr	s30, [r0]
20000546:	edd8 6a00 	vldr	s13, [r8]
2000054a:	ee3f fa66 	vsub.f32	s30, s30, s13
    
    const float x0f = 2.f * p * k_wt_saw_size;
    const uint32_t x0p = (uint32_t)x0f;
    
    uint32_t x0 = x0p, x1 = x0p+1;
    float sign = 1.f;
2000054e:	bf98      	it	ls
20000550:	eeb7 ea00 	vmovls.f32	s28, #112	; 0x3f800000  1.0
20000554:	eee7 6a8f 	vfma.f32	s13, s15, s30
    if (x0p >= k_wt_saw_size) {
      x0 = k_wt_saw_size - (x0p & k_wt_saw_mask);
      x1 = x0 - 1;
      sign = -1.f;
20000558:	bf88      	it	hi
2000055a:	eebf ea00 	vmovhi.f32	s28, #240	; 0xbf800000 -1.0
2000055e:	ee66 7a8e 	vmul.f32	s15, s13, s28
		
		// Apply supermix, can set from dominant to inaudible.
		
		// =========================================================
		
		main_sig = (1.f - supermix) * main_sig + (supermix * supersig);
20000562:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
		*
		*/ 
		
		// =========================================================
		
		const float supersig = 0.5f * osc_bl2_sawf(phisuper, index);
20000566:	eeed 7ace 	vfms.f32	s15, s27, s28
2000056a:	ee67 7aae 	vmul.f32	s15, s15, s29
2000056e:	eeed 7a8e 	vfma.f32	s15, s27, s28
		
		// Apply supermix, can set from dominant to inaudible.
		
		// =========================================================
		
		main_sig = (1.f - supermix) * main_sig + (supermix * supersig);
20000572:	ee34 eac1 	vsub.f32	s28, s9, s2
		*
		*/ 
		
		// =========================================================
		
		const float supersig = 0.5f * osc_bl2_sawf(phisuper, index);
20000576:	ee67 7aa3 	vmul.f32	s15, s15, s7
		
		// Apply supermix, can set from dominant to inaudible.
		
		// =========================================================
		
		main_sig = (1.f - supermix) * main_sig + (supermix * supersig);
2000057a:	ee61 da27 	vmul.f32	s27, s2, s15
2000057e:	eeed da0e 	vfma.f32	s27, s26, s28
		
		// Apply ringmix, can set as dominant or inaudible.
		
		// =========================================================
		
		main_sig = (1.f - ringmix) * main_sig + ringmix * (subsig * main_sig) + ringmix * (supersig * main_sig);
20000582:	ee27 7a2d 	vmul.f32	s14, s14, s27
		
		// Apply supermix, can set from dominant to inaudible.
		
		// =========================================================
		
		main_sig = (1.f - supermix) * main_sig + (supermix * supersig);
20000586:	eeb0 da6d 	vmov.f32	s26, s27
		
		// Apply ringmix, can set as dominant or inaudible.
		
		// =========================================================
		
		main_sig = (1.f - ringmix) * main_sig + ringmix * (subsig * main_sig) + ringmix * (supersig * main_sig);
2000058a:	ee27 7a03 	vmul.f32	s14, s14, s6
2000058e:	ee74 dac3 	vsub.f32	s27, s9, s6
20000592:	ee67 7a8d 	vmul.f32	s15, s15, s26
20000596:	eead 7a2d 	vfma.f32	s14, s26, s27
2000059a:	eea3 7a27 	vfma.f32	s14, s6, s15

/** FSEL construct
 */
static inline __attribute__((optimize("Ofast"),always_inline))
float fsel(const float a, const float b, const float c) {
  return (a >= 0) ? b : c;
2000059e:	eeb4 7aec 	vcmpe.f32	s14, s25
200005a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200005a6:	eef0 7a47 	vmov.f32	s15, s14
200005aa:	db07      	blt.n	200005bc <_hook_cycle+0x512>
200005ac:	eeb4 7ae6 	vcmpe.f32	s14, s13
200005b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200005b4:	bfa8      	it	ge
200005b6:	eef0 7a66 	vmovge.f32	s15, s13
200005ba:	e001      	b.n	200005c0 <_hook_cycle+0x516>
200005bc:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
		*
		*/ 
		
		// =========================================================
		
		*(y++) = f32_to_q31(main_sig);
200005c0:	ee27 7aa7 	vmul.f32	s14, s15, s15
200005c4:	eef4 6a00 	vmov.f32	s13, #64	; 0x3e000000  0.125
200005c8:	ee27 7ac7 	vnmul.f32	s14, s15, s14
200005cc:	f8df 8078 	ldr.w	r8, [pc, #120]	; 20000648 <_hook_cycle+0x59e>
200005d0:	eee7 7a26 	vfma.f32	s15, s14, s13
200005d4:	4608      	mov	r0, r1
200005d6:	eefe 7ae0 	vcvt.s32.f32	s15, s15, #31
200005da:	ece7 7a01 	vstmia	r7!, {s15}
		// Update local Central and Side osc phases
		
		// =========================================================
		
		for(int i = 0; i < NUM_OSC; i++) {
			phi[i] += s.w0[i];
200005de:	ed90 7a00 	vldr	s14, [r0]
200005e2:	ecf8 7a01 	vldmia	r8!, {s15}
200005e6:	ee77 7a87 	vadd.f32	s15, s15, s14
			phi[i] -= (uint32_t)phi[i];
200005ea:	eebc 7ae7 	vcvt.u32.f32	s14, s15
200005ee:	eeb8 7a47 	vcvt.f32.u32	s14, s14
200005f2:	ee77 7ac7 	vsub.f32	s15, s15, s14
200005f6:	ece0 7a01 	vstmia	r0!, {s15}
		
		// Update local Central and Side osc phases
		
		// =========================================================
		
		for(int i = 0; i < NUM_OSC; i++) {
200005fa:	4584      	cmp	ip, r0
200005fc:	d1ef      	bne.n	200005de <_hook_cycle+0x534>
		
		// Update local sub-osc phase
		
		// =========================================================
		
		phisub += s.w0sub;
200005fe:	ee75 5a85 	vadd.f32	s11, s11, s10
		
		// Update local super-osc phase
		
		// =========================================================
		
		phisuper += s.w0super;
20000602:	ee36 6a02 	vadd.f32	s12, s12, s4
		// Update local sub-osc phase
		
		// =========================================================
		
		phisub += s.w0sub;
		phisub -= (uint32_t)phisub;
20000606:	eefc 7ae5 	vcvt.u32.f32	s15, s11
		
		// Update local LFO
		
		// =========================================================
		
		lfoz += lfo_inc;
2000060a:	ee34 4a00 	vadd.f32	s8, s8, s0
		// Update local sub-osc phase
		
		// =========================================================
		
		phisub += s.w0sub;
		phisub -= (uint32_t)phisub;
2000060e:	eef8 7a67 	vcvt.f32.u32	s15, s15
20000612:	ee75 5ae7 	vsub.f32	s11, s11, s15
		// Update local super-osc phase
		
		// =========================================================
		
		phisuper += s.w0super;
		phisuper -= (uint32_t)phisuper;
20000616:	eefc 7ac6 	vcvt.u32.f32	s15, s12
2000061a:	eef8 7a67 	vcvt.f32.u32	s15, s15
2000061e:	ee36 6a67 	vsub.f32	s12, s12, s15
	// =========================================================
	
	// Load the buffer.
	
	// =========================================================
	for (; y != y_e; ) {
20000622:	e61e      	b.n	20000262 <_hook_cycle+0x1b8>
	
	// Update global Central and Side osc phases
	
	// =========================================================
	for(int i = 0; i < NUM_OSC; i++) {
		s.phi[i] = phi[i];
20000624:	f851 3b04 	ldr.w	r3, [r1], #4
20000628:	f846 3b04 	str.w	r3, [r6], #4
	// =========================================================
	
	// Update global Central and Side osc phases
	
	// =========================================================
	for(int i = 0; i < NUM_OSC; i++) {
2000062c:	45b6      	cmp	lr, r6
2000062e:	d1f9      	bne.n	20000624 <_hook_cycle+0x57a>
	
	// Update global sub and super wave phases
	
	// =========================================================
	
	s.phisub = phisub;
20000630:	edc4 5a08 	vstr	s11, [r4, #32]
	s.phisuper = phisuper;
20000634:	ed84 6a07 	vstr	s12, [r4, #28]
	
	// Update global final LFO state
	
	// =========================================================
	
	s.lfoz = lfoz;
20000638:	ed84 4a13 	vstr	s8, [r4, #76]	; 0x4c
	
	// =========================================================
}
2000063c:	b00a      	add	sp, #40	; 0x28
2000063e:	ecbd 8b10 	vpop	{d8-d15}
20000642:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
20000646:	bf00      	nop
20000648:	20000aac 	.word	0x20000aac

2000064c <_hook_on>:
2000064c:	4770      	bx	lr

2000064e <_hook_off>:

void OSC_NOTEON(const user_osc_param_t *const params) {
	(void)params;
}

void OSC_NOTEOFF(const user_osc_param_t *const params) {
2000064e:	4770      	bx	lr

20000650 <_hook_param>:
	(void)params;
}

void OSC_PARAM(uint16_t index, uint16_t value) { 
20000650:	ee07 1a90 	vmov	s15, r1
	
	// Update parameter values from user control input
	
	// =========================================================
	
	switch (index) {
20000654:	2807      	cmp	r0, #7
20000656:	d879      	bhi.n	2000074c <_hook_param+0xfc>
20000658:	e8df f000 	tbb	[pc, r0]
2000065c:	553a1f04 	.word	0x553a1f04
20000660:	6f657878 	.word	0x6f657878
			/*
			* Sub mix
			* Percent parameter
			* Scale in 0.0 - 1.00
			*/ 
			p.submix = clip01f(value * 0.01f); break; 
20000664:	eef8 7ae7 	vcvt.f32.s32	s15, s15
20000668:	ed9f 7a39 	vldr	s14, [pc, #228]	; 20000750 <_hook_param+0x100>
2000066c:	ee67 7a87 	vmul.f32	s15, s15, s14
20000670:	eef5 7ac0 	vcmpe.f32	s15, #0.0
20000674:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000678:	db09      	blt.n	2000068e <_hook_param+0x3e>
2000067a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
2000067e:	eef4 7ac7 	vcmpe.f32	s15, s14
20000682:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
20000686:	bfa8      	it	ge
20000688:	eef0 7a47 	vmovge.f32	s15, s14
2000068c:	e001      	b.n	20000692 <_hook_param+0x42>
2000068e:	eddf 7a31 	vldr	s15, [pc, #196]	; 20000754 <_hook_param+0x104>
20000692:	4b31      	ldr	r3, [pc, #196]	; (20000758 <_hook_param+0x108>)
20000694:	edc3 7a15 	vstr	s15, [r3, #84]	; 0x54
20000698:	4770      	bx	lr
			/*
			* Super mix
			* Percent parameter
			* Scale in 0.0 - 1.00
			*/ 
			p.supermix = clip01f(value * 0.01f); break; 
2000069a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2000069e:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 20000750 <_hook_param+0x100>
200006a2:	ee67 7a87 	vmul.f32	s15, s15, s14
200006a6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
200006aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200006ae:	db09      	blt.n	200006c4 <_hook_param+0x74>
200006b0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
200006b4:	eef4 7ac7 	vcmpe.f32	s15, s14
200006b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200006bc:	bfa8      	it	ge
200006be:	eef0 7a47 	vmovge.f32	s15, s14
200006c2:	e001      	b.n	200006c8 <_hook_param+0x78>
200006c4:	eddf 7a23 	vldr	s15, [pc, #140]	; 20000754 <_hook_param+0x104>
200006c8:	4b23      	ldr	r3, [pc, #140]	; (20000758 <_hook_param+0x108>)
200006ca:	edc3 7a16 	vstr	s15, [r3, #88]	; 0x58
200006ce:	4770      	bx	lr
			/*
			* Ring mix
			* Percent parameter
			* Scale in 0.0 - 1.00
			*/ 
			p.ringmix = clip01f(value * 0.01f); break;
200006d0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
200006d4:	ed9f 7a1e 	vldr	s14, [pc, #120]	; 20000750 <_hook_param+0x100>
200006d8:	ee67 7a87 	vmul.f32	s15, s15, s14
200006dc:	eef5 7ac0 	vcmpe.f32	s15, #0.0
200006e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200006e4:	db09      	blt.n	200006fa <_hook_param+0xaa>
200006e6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
200006ea:	eef4 7ac7 	vcmpe.f32	s15, s14
200006ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200006f2:	bfa8      	it	ge
200006f4:	eef0 7a47 	vmovge.f32	s15, s14
200006f8:	e001      	b.n	200006fe <_hook_param+0xae>
200006fa:	eddf 7a16 	vldr	s15, [pc, #88]	; 20000754 <_hook_param+0x104>
200006fe:	4b16      	ldr	r3, [pc, #88]	; (20000758 <_hook_param+0x108>)
20000700:	edc3 7a17 	vstr	s15, [r3, #92]	; 0x5c
20000704:	4770      	bx	lr
			/*
			* Detune
			* Percent parameter
			* Scale in 0.0 - 1.00
			*/ 
			p.detune_value = value * 0.01f;
20000706:	4b14      	ldr	r3, [pc, #80]	; (20000758 <_hook_param+0x108>)
20000708:	ed9f 7a11 	vldr	s14, [pc, #68]	; 20000750 <_hook_param+0x100>
			// Raise flag
			s.flags |= UberSaw::flag_detune; break;
2000070c:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
			/*
			* Detune
			* Percent parameter
			* Scale in 0.0 - 1.00
			*/ 
			p.detune_value = value * 0.01f;
20000710:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			// Raise flag
			s.flags |= UberSaw::flag_detune; break;
20000714:	f042 0202 	orr.w	r2, r2, #2
			/*
			* Detune
			* Percent parameter
			* Scale in 0.0 - 1.00
			*/ 
			p.detune_value = value * 0.01f;
20000718:	ee67 7a87 	vmul.f32	s15, s15, s14
			// Raise flag
			s.flags |= UberSaw::flag_detune; break;
2000071c:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
			/*
			* Detune
			* Percent parameter
			* Scale in 0.0 - 1.00
			*/ 
			p.detune_value = value * 0.01f;
20000720:	edc3 7a19 	vstr	s15, [r3, #100]	; 0x64
			// Raise flag
			s.flags |= UberSaw::flag_detune; break;
20000724:	4770      	bx	lr
		case k_user_osc_param_id6: break;
			
		case k_user_osc_param_shape:
			// 10bit parameter
			// Value from A knob
			p.shape = param_val_to_f32(value); break;
20000726:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2000072a:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 2000075c <_hook_param+0x10c>
2000072e:	4b0a      	ldr	r3, [pc, #40]	; (20000758 <_hook_param+0x108>)
20000730:	ee67 7a87 	vmul.f32	s15, s15, s14
20000734:	edc3 7a1a 	vstr	s15, [r3, #104]	; 0x68
20000738:	4770      	bx	lr
			
		case k_user_osc_param_shiftshape:
			// 10bit parameter
			// Value from B knob
			p.shiftshape = param_val_to_f32(value); break;
2000073a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
2000073e:	ed9f 7a07 	vldr	s14, [pc, #28]	; 2000075c <_hook_param+0x10c>
20000742:	4b05      	ldr	r3, [pc, #20]	; (20000758 <_hook_param+0x108>)
20000744:	ee67 7a87 	vmul.f32	s15, s15, s14
20000748:	edc3 7a1b 	vstr	s15, [r3, #108]	; 0x6c
2000074c:	4770      	bx	lr
2000074e:	bf00      	nop
20000750:	3c23d70a 	.word	0x3c23d70a
20000754:	00000000 	.word	0x00000000
20000758:	20000a88 	.word	0x20000a88
2000075c:	3a802008 	.word	0x3a802008

20000760 <memcpy>:
20000760:	4684      	mov	ip, r0
20000762:	ea41 0300 	orr.w	r3, r1, r0
20000766:	f013 0303 	ands.w	r3, r3, #3
2000076a:	d16d      	bne.n	20000848 <memcpy+0xe8>
2000076c:	3a40      	subs	r2, #64	; 0x40
2000076e:	d341      	bcc.n	200007f4 <memcpy+0x94>
20000770:	f851 3b04 	ldr.w	r3, [r1], #4
20000774:	f840 3b04 	str.w	r3, [r0], #4
20000778:	f851 3b04 	ldr.w	r3, [r1], #4
2000077c:	f840 3b04 	str.w	r3, [r0], #4
20000780:	f851 3b04 	ldr.w	r3, [r1], #4
20000784:	f840 3b04 	str.w	r3, [r0], #4
20000788:	f851 3b04 	ldr.w	r3, [r1], #4
2000078c:	f840 3b04 	str.w	r3, [r0], #4
20000790:	f851 3b04 	ldr.w	r3, [r1], #4
20000794:	f840 3b04 	str.w	r3, [r0], #4
20000798:	f851 3b04 	ldr.w	r3, [r1], #4
2000079c:	f840 3b04 	str.w	r3, [r0], #4
200007a0:	f851 3b04 	ldr.w	r3, [r1], #4
200007a4:	f840 3b04 	str.w	r3, [r0], #4
200007a8:	f851 3b04 	ldr.w	r3, [r1], #4
200007ac:	f840 3b04 	str.w	r3, [r0], #4
200007b0:	f851 3b04 	ldr.w	r3, [r1], #4
200007b4:	f840 3b04 	str.w	r3, [r0], #4
200007b8:	f851 3b04 	ldr.w	r3, [r1], #4
200007bc:	f840 3b04 	str.w	r3, [r0], #4
200007c0:	f851 3b04 	ldr.w	r3, [r1], #4
200007c4:	f840 3b04 	str.w	r3, [r0], #4
200007c8:	f851 3b04 	ldr.w	r3, [r1], #4
200007cc:	f840 3b04 	str.w	r3, [r0], #4
200007d0:	f851 3b04 	ldr.w	r3, [r1], #4
200007d4:	f840 3b04 	str.w	r3, [r0], #4
200007d8:	f851 3b04 	ldr.w	r3, [r1], #4
200007dc:	f840 3b04 	str.w	r3, [r0], #4
200007e0:	f851 3b04 	ldr.w	r3, [r1], #4
200007e4:	f840 3b04 	str.w	r3, [r0], #4
200007e8:	f851 3b04 	ldr.w	r3, [r1], #4
200007ec:	f840 3b04 	str.w	r3, [r0], #4
200007f0:	3a40      	subs	r2, #64	; 0x40
200007f2:	d2bd      	bcs.n	20000770 <memcpy+0x10>
200007f4:	3230      	adds	r2, #48	; 0x30
200007f6:	d311      	bcc.n	2000081c <memcpy+0xbc>
200007f8:	f851 3b04 	ldr.w	r3, [r1], #4
200007fc:	f840 3b04 	str.w	r3, [r0], #4
20000800:	f851 3b04 	ldr.w	r3, [r1], #4
20000804:	f840 3b04 	str.w	r3, [r0], #4
20000808:	f851 3b04 	ldr.w	r3, [r1], #4
2000080c:	f840 3b04 	str.w	r3, [r0], #4
20000810:	f851 3b04 	ldr.w	r3, [r1], #4
20000814:	f840 3b04 	str.w	r3, [r0], #4
20000818:	3a10      	subs	r2, #16
2000081a:	d2ed      	bcs.n	200007f8 <memcpy+0x98>
2000081c:	320c      	adds	r2, #12
2000081e:	d305      	bcc.n	2000082c <memcpy+0xcc>
20000820:	f851 3b04 	ldr.w	r3, [r1], #4
20000824:	f840 3b04 	str.w	r3, [r0], #4
20000828:	3a04      	subs	r2, #4
2000082a:	d2f9      	bcs.n	20000820 <memcpy+0xc0>
2000082c:	3204      	adds	r2, #4
2000082e:	d008      	beq.n	20000842 <memcpy+0xe2>
20000830:	07d2      	lsls	r2, r2, #31
20000832:	bf1c      	itt	ne
20000834:	f811 3b01 	ldrbne.w	r3, [r1], #1
20000838:	f800 3b01 	strbne.w	r3, [r0], #1
2000083c:	d301      	bcc.n	20000842 <memcpy+0xe2>
2000083e:	880b      	ldrh	r3, [r1, #0]
20000840:	8003      	strh	r3, [r0, #0]
20000842:	4660      	mov	r0, ip
20000844:	4770      	bx	lr
20000846:	bf00      	nop
20000848:	2a08      	cmp	r2, #8
2000084a:	d313      	bcc.n	20000874 <memcpy+0x114>
2000084c:	078b      	lsls	r3, r1, #30
2000084e:	d08d      	beq.n	2000076c <memcpy+0xc>
20000850:	f010 0303 	ands.w	r3, r0, #3
20000854:	d08a      	beq.n	2000076c <memcpy+0xc>
20000856:	f1c3 0304 	rsb	r3, r3, #4
2000085a:	1ad2      	subs	r2, r2, r3
2000085c:	07db      	lsls	r3, r3, #31
2000085e:	bf1c      	itt	ne
20000860:	f811 3b01 	ldrbne.w	r3, [r1], #1
20000864:	f800 3b01 	strbne.w	r3, [r0], #1
20000868:	d380      	bcc.n	2000076c <memcpy+0xc>
2000086a:	f831 3b02 	ldrh.w	r3, [r1], #2
2000086e:	f820 3b02 	strh.w	r3, [r0], #2
20000872:	e77b      	b.n	2000076c <memcpy+0xc>
20000874:	3a04      	subs	r2, #4
20000876:	d3d9      	bcc.n	2000082c <memcpy+0xcc>
20000878:	3a01      	subs	r2, #1
2000087a:	f811 3b01 	ldrb.w	r3, [r1], #1
2000087e:	f800 3b01 	strb.w	r3, [r0], #1
20000882:	d2f9      	bcs.n	20000878 <memcpy+0x118>
20000884:	780b      	ldrb	r3, [r1, #0]
20000886:	7003      	strb	r3, [r0, #0]
20000888:	784b      	ldrb	r3, [r1, #1]
2000088a:	7043      	strb	r3, [r0, #1]
2000088c:	788b      	ldrb	r3, [r1, #2]
2000088e:	7083      	strb	r3, [r0, #2]
20000890:	4660      	mov	r0, ip
20000892:	4770      	bx	lr

20000894 <_ZN7UberSaw4initEv>:

	UberSaw(void) {
		init();
	}

	void init(void) {
20000894:	b510      	push	{r4, lr}
20000896:	4603      	mov	r3, r0
20000898:	b096      	sub	sp, #88	; 0x58
			lfo(ZEROF),
			lfoz(ZEROF),
			flags(flags_none)
		{
			for(int i = 0; i < NUM_OSC; i++) {
				w0[i] = MAIN_TUNING; 
2000089a:	4811      	ldr	r0, [pc, #68]	; (200008e0 <_ZN7UberSaw4initEv+0x4c>)
2000089c:	aa0a      	add	r2, sp, #40	; 0x28
2000089e:	a911      	add	r1, sp, #68	; 0x44
200008a0:	f842 0b04 	str.w	r0, [r2], #4
			w0sub(SUB_TUNING),
			lfo(ZEROF),
			lfoz(ZEROF),
			flags(flags_none)
		{
			for(int i = 0; i < NUM_OSC; i++) {
200008a4:	4291      	cmp	r1, r2
200008a6:	d1fb      	bne.n	200008a0 <_ZN7UberSaw4initEv+0xc>
	UberSaw(void) {
		init();
	}

	void init(void) {
		state = State();
200008a8:	4a0e      	ldr	r2, [pc, #56]	; (200008e4 <_ZN7UberSaw4initEv+0x50>)
200008aa:	9211      	str	r2, [sp, #68]	; 0x44
200008ac:	4a0e      	ldr	r2, [pc, #56]	; (200008e8 <_ZN7UberSaw4initEv+0x54>)
200008ae:	9212      	str	r2, [sp, #72]	; 0x48
200008b0:	f89d 2054 	ldrb.w	r2, [sp, #84]	; 0x54
200008b4:	f36f 0201 	bfc	r2, #0, #2
200008b8:	2400      	movs	r4, #0
200008ba:	f88d 2054 	strb.w	r2, [sp, #84]	; 0x54
200008be:	a901      	add	r1, sp, #4
200008c0:	2251      	movs	r2, #81	; 0x51
200008c2:	4618      	mov	r0, r3
200008c4:	9413      	str	r4, [sp, #76]	; 0x4c
200008c6:	9414      	str	r4, [sp, #80]	; 0x50
200008c8:	f7ff ff4a 	bl	20000760 <memcpy>
		params = Params();
200008cc:	6544      	str	r4, [r0, #84]	; 0x54
200008ce:	6584      	str	r4, [r0, #88]	; 0x58
200008d0:	65c4      	str	r4, [r0, #92]	; 0x5c
200008d2:	6604      	str	r4, [r0, #96]	; 0x60
200008d4:	6644      	str	r4, [r0, #100]	; 0x64
200008d6:	6684      	str	r4, [r0, #104]	; 0x68
200008d8:	66c4      	str	r4, [r0, #108]	; 0x6c
	}
200008da:	b016      	add	sp, #88	; 0x58
200008dc:	bd10      	pop	{r4, pc}
200008de:	bf00      	nop
200008e0:	3c162fc9 	.word	0x3c162fc9
200008e4:	3c962fc9 	.word	0x3c962fc9
200008e8:	3b962fc9 	.word	0x3b962fc9

200008ec <_ZN7UberSaw12updateDetuneEv>:
	}
	
	// Implements Adam Szabo's method
	inline void updateDetune() {
		// Get linear detune control value
		const float detune_value = params.detune_value;
200008ec:	ed90 7a19 	vldr	s14, [r0, #100]	; 0x64
		This loop calculates powers and provides better 
		performance for this function than the pow function or
		the functions provided in float_math.h
		*/
		
		for(int i = 0; i < 10; i++) {
200008f0:	2300      	movs	r3, #0
		const float detune_value = params.detune_value;
		
		// Define variables for exponent calculations
		float x11, x10, x9, x8, x7, x6, x5, x4, x3, x2, x1;
		
		x11 = x10 = x9 = x8 = x7 = x6 = x5 = x4 = x3 = x2 = x1 = detune_value;  
200008f2:	eef0 6a47 	vmov.f32	s13, s14
200008f6:	eeb0 6a47 	vmov.f32	s12, s14
200008fa:	eef0 5a47 	vmov.f32	s11, s14
200008fe:	eeb0 5a47 	vmov.f32	s10, s14
20000902:	eef0 4a47 	vmov.f32	s9, s14
20000906:	eeb0 4a47 	vmov.f32	s8, s14
2000090a:	eef0 3a47 	vmov.f32	s7, s14
2000090e:	eeb0 3a47 	vmov.f32	s6, s14
20000912:	eeb0 2a47 	vmov.f32	s4, s14
20000916:	eef0 2a47 	vmov.f32	s5, s14
		performance for this function than the pow function or
		the functions provided in float_math.h
		*/
		
		for(int i = 0; i < 10; i++) {
			x11 *= detune_value;
2000091a:	ee62 2a87 	vmul.f32	s5, s5, s14
			if(i > 0) {
2000091e:	b30b      	cbz	r3, 20000964 <_ZN7UberSaw12updateDetuneEv+0x78>
				x10 *= detune_value;
			}
			if (i > 1) {
20000920:	2b01      	cmp	r3, #1
		*/
		
		for(int i = 0; i < 10; i++) {
			x11 *= detune_value;
			if(i > 0) {
				x10 *= detune_value;
20000922:	ee22 2a07 	vmul.f32	s4, s4, s14
			}
			if (i > 1) {
20000926:	d01d      	beq.n	20000964 <_ZN7UberSaw12updateDetuneEv+0x78>
				x9 *= detune_value;
			}
			if (i > 2) {
20000928:	2b02      	cmp	r3, #2
			x11 *= detune_value;
			if(i > 0) {
				x10 *= detune_value;
			}
			if (i > 1) {
				x9 *= detune_value;
2000092a:	ee23 3a07 	vmul.f32	s6, s6, s14
			}
			if (i > 2) {
2000092e:	d019      	beq.n	20000964 <_ZN7UberSaw12updateDetuneEv+0x78>
				x8 *= detune_value;
			}
			if (i > 3) {
20000930:	2b03      	cmp	r3, #3
			}
			if (i > 1) {
				x9 *= detune_value;
			}
			if (i > 2) {
				x8 *= detune_value;
20000932:	ee63 3a87 	vmul.f32	s7, s7, s14
			}
			if (i > 3) {
20000936:	d015      	beq.n	20000964 <_ZN7UberSaw12updateDetuneEv+0x78>
				x7 *= detune_value;
			}
			if (i > 4) {
20000938:	2b04      	cmp	r3, #4
			}
			if (i > 2) {
				x8 *= detune_value;
			}
			if (i > 3) {
				x7 *= detune_value;
2000093a:	ee24 4a07 	vmul.f32	s8, s8, s14
			}
			if (i > 4) {
2000093e:	d011      	beq.n	20000964 <_ZN7UberSaw12updateDetuneEv+0x78>
				x6 *= detune_value;
			}
			if (i > 5) {
20000940:	2b05      	cmp	r3, #5
			}
			if (i > 3) {
				x7 *= detune_value;
			}
			if (i > 4) {
				x6 *= detune_value;
20000942:	ee64 4a87 	vmul.f32	s9, s9, s14
			}
			if (i > 5) {
20000946:	d00d      	beq.n	20000964 <_ZN7UberSaw12updateDetuneEv+0x78>
				x5 *= detune_value;
			}
			if (i > 6) {
20000948:	2b06      	cmp	r3, #6
			}
			if (i > 4) {
				x6 *= detune_value;
			}
			if (i > 5) {
				x5 *= detune_value;
2000094a:	ee25 5a07 	vmul.f32	s10, s10, s14
			}
			if (i > 6) {
2000094e:	d009      	beq.n	20000964 <_ZN7UberSaw12updateDetuneEv+0x78>
				x4 *= detune_value;
			}
			if (i > 7) {
20000950:	2b07      	cmp	r3, #7
			}
			if (i > 5) {
				x5 *= detune_value;
			}
			if (i > 6) {
				x4 *= detune_value;
20000952:	ee65 5a87 	vmul.f32	s11, s11, s14
			}
			if (i > 7) {
20000956:	d005      	beq.n	20000964 <_ZN7UberSaw12updateDetuneEv+0x78>
				x3 *= detune_value;
			}
			if (i > 8) {
20000958:	2b09      	cmp	r3, #9
			}
			if (i > 6) {
				x4 *= detune_value;
			}
			if (i > 7) {
				x3 *= detune_value;
2000095a:	ee26 6a07 	vmul.f32	s12, s12, s14
			}
			if (i > 8) {
				x2 *= detune_value;
2000095e:	bf08      	it	eq
20000960:	ee66 6a87 	vmuleq.f32	s13, s13, s14
		This loop calculates powers and provides better 
		performance for this function than the pow function or
		the functions provided in float_math.h
		*/
		
		for(int i = 0; i < 10; i++) {
20000964:	3301      	adds	r3, #1
20000966:	2b0a      	cmp	r3, #10
20000968:	d1d7      	bne.n	2000091a <_ZN7UberSaw12updateDetuneEv+0x2e>
		x4 *= 3425.0836591318;
		x3 *= 404.2703938388;
		x2 *= 24.1878824391;
		x1 *= 0.6717417634;
		
		params.detune = x11 - x10 + x9 - x8 + x7 - x6 + x5 - x4 + x3 - x2 + x1 + 0.0030115596;
2000096a:	eddf 7a22 	vldr	s15, [pc, #136]	; 200009f4 <_ZN7UberSaw12updateDetuneEv+0x108>
2000096e:	ee67 7ac2 	vnmul.f32	s15, s15, s4
20000972:	ed9f 2a21 	vldr	s4, [pc, #132]	; 200009f8 <_ZN7UberSaw12updateDetuneEv+0x10c>
20000976:	eee2 7a82 	vfma.f32	s15, s5, s4
2000097a:	eddf 2a20 	vldr	s5, [pc, #128]	; 200009fc <_ZN7UberSaw12updateDetuneEv+0x110>
2000097e:	eee3 7a22 	vfma.f32	s15, s6, s5
20000982:	ed9f 3a1f 	vldr	s6, [pc, #124]	; 20000a00 <_ZN7UberSaw12updateDetuneEv+0x114>
20000986:	eee3 7ac3 	vfms.f32	s15, s7, s6
2000098a:	eddf 3a1e 	vldr	s7, [pc, #120]	; 20000a04 <_ZN7UberSaw12updateDetuneEv+0x118>
2000098e:	eee4 7a23 	vfma.f32	s15, s8, s7
20000992:	ed9f 4a1d 	vldr	s8, [pc, #116]	; 20000a08 <_ZN7UberSaw12updateDetuneEv+0x11c>
20000996:	eee4 7ac4 	vfms.f32	s15, s9, s8
2000099a:	eddf 4a1c 	vldr	s9, [pc, #112]	; 20000a0c <_ZN7UberSaw12updateDetuneEv+0x120>
2000099e:	eee5 7a24 	vfma.f32	s15, s10, s9
200009a2:	ed9f 5a1b 	vldr	s10, [pc, #108]	; 20000a10 <_ZN7UberSaw12updateDetuneEv+0x124>
200009a6:	eee5 7ac5 	vfms.f32	s15, s11, s10
200009aa:	eddf 5a1a 	vldr	s11, [pc, #104]	; 20000a14 <_ZN7UberSaw12updateDetuneEv+0x128>
200009ae:	eee6 7a25 	vfma.f32	s15, s12, s11
200009b2:	ed9f 6a19 	vldr	s12, [pc, #100]	; 20000a18 <_ZN7UberSaw12updateDetuneEv+0x12c>
200009b6:	eee6 7ac6 	vfms.f32	s15, s13, s12
200009ba:	eddf 6a18 	vldr	s13, [pc, #96]	; 20000a1c <_ZN7UberSaw12updateDetuneEv+0x130>
200009be:	eee7 7a26 	vfma.f32	s15, s14, s13
200009c2:	ed9f 7a17 	vldr	s14, [pc, #92]	; 20000a20 <_ZN7UberSaw12updateDetuneEv+0x134>
200009c6:	ee77 7a87 	vadd.f32	s15, s15, s14
200009ca:	eef5 7ac0 	vcmpe.f32	s15, #0.0
200009ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200009d2:	db09      	blt.n	200009e8 <_ZN7UberSaw12updateDetuneEv+0xfc>
200009d4:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
200009d8:	eef4 7ac7 	vcmpe.f32	s15, s14
200009dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
200009e0:	bfa8      	it	ge
200009e2:	eef0 7a47 	vmovge.f32	s15, s14
200009e6:	e001      	b.n	200009ec <_ZN7UberSaw12updateDetuneEv+0x100>
200009e8:	eddf 7a0e 	vldr	s15, [pc, #56]	; 20000a24 <_ZN7UberSaw12updateDetuneEv+0x138>
		
		// Clip in range [0-1]
		params.detune = clip01f(params.detune);
200009ec:	edc0 7a18 	vstr	s15, [r0, #96]	; 0x60
200009f0:	4770      	bx	lr
200009f2:	bf00      	nop
200009f4:	474682dd 	.word	0x474682dd
200009f8:	461cb2ed 	.word	0x461cb2ed
200009fc:	47d981be 	.word	0x47d981be
20000a00:	4806e9ab 	.word	0x4806e9ab
20000a04:	47d04cd5 	.word	0x47d04cd5
20000a08:	474f36f7 	.word	0x474f36f7
20000a0c:	4684f7e7 	.word	0x4684f7e7
20000a10:	45561157 	.word	0x45561157
20000a14:	43ca229c 	.word	0x43ca229c
20000a18:	41c180c9 	.word	0x41c180c9
20000a1c:	3f2bf745 	.word	0x3f2bf745
20000a20:	3b455d96 	.word	0x3b455d96
20000a24:	00000000 	.word	0x00000000

20000a28 <_GLOBAL__sub_I__hook_init>:
		State(void) :
			w0super(SUPER_TUNING),
			w0sub(SUB_TUNING),
			lfo(ZEROF),
			lfoz(ZEROF),
			flags(flags_none)
20000a28:	4b11      	ldr	r3, [pc, #68]	; (20000a70 <_GLOBAL__sub_I__hook_init+0x48>)
20000a2a:	4a12      	ldr	r2, [pc, #72]	; (20000a74 <_GLOBAL__sub_I__hook_init+0x4c>)
20000a2c:	f893 1050 	ldrb.w	r1, [r3, #80]	; 0x50
			
		default: break;
	}
	
	// =========================================================
}
20000a30:	b510      	push	{r4, lr}
20000a32:	641a      	str	r2, [r3, #64]	; 0x40
20000a34:	4a10      	ldr	r2, [pc, #64]	; (20000a78 <_GLOBAL__sub_I__hook_init+0x50>)
20000a36:	645a      	str	r2, [r3, #68]	; 0x44
20000a38:	f36f 0101 	bfc	r1, #0, #2
20000a3c:	2200      	movs	r2, #0
		{
			for(int i = 0; i < NUM_OSC; i++) {
				w0[i] = MAIN_TUNING; 
20000a3e:	4c0f      	ldr	r4, [pc, #60]	; (20000a7c <_GLOBAL__sub_I__hook_init+0x54>)
		State(void) :
			w0super(SUPER_TUNING),
			w0sub(SUB_TUNING),
			lfo(ZEROF),
			lfoz(ZEROF),
			flags(flags_none)
20000a40:	f883 1050 	strb.w	r1, [r3, #80]	; 0x50
20000a44:	649a      	str	r2, [r3, #72]	; 0x48
20000a46:	64da      	str	r2, [r3, #76]	; 0x4c
20000a48:	f103 0124 	add.w	r1, r3, #36	; 0x24
20000a4c:	f103 0040 	add.w	r0, r3, #64	; 0x40
		{
			for(int i = 0; i < NUM_OSC; i++) {
				w0[i] = MAIN_TUNING; 
20000a50:	f841 4b04 	str.w	r4, [r1], #4
			w0sub(SUB_TUNING),
			lfo(ZEROF),
			lfoz(ZEROF),
			flags(flags_none)
		{
			for(int i = 0; i < NUM_OSC; i++) {
20000a54:	4281      	cmp	r1, r0
20000a56:	d1fb      	bne.n	20000a50 <_GLOBAL__sub_I__hook_init+0x28>
			supermix(ZEROF),
			ringmix(ZEROF),
			detune(ZEROF),
			detune_value(ZEROF),
			shape(ZEROF),
			shiftshape(ZEROF) 
20000a58:	655a      	str	r2, [r3, #84]	; 0x54
20000a5a:	659a      	str	r2, [r3, #88]	; 0x58
20000a5c:	65da      	str	r2, [r3, #92]	; 0x5c
20000a5e:	661a      	str	r2, [r3, #96]	; 0x60
20000a60:	665a      	str	r2, [r3, #100]	; 0x64
20000a62:	669a      	str	r2, [r3, #104]	; 0x68
20000a64:	66da      	str	r2, [r3, #108]	; 0x6c
			}
		}
	};

	UberSaw(void) {
		init();
20000a66:	4802      	ldr	r0, [pc, #8]	; (20000a70 <_GLOBAL__sub_I__hook_init+0x48>)
20000a68:	f7ff ff14 	bl	20000894 <_ZN7UberSaw4initEv>
20000a6c:	bd10      	pop	{r4, pc}
20000a6e:	bf00      	nop
20000a70:	20000a88 	.word	0x20000a88
20000a74:	3c962fc9 	.word	0x3c962fc9
20000a78:	3b962fc9 	.word	0x3b962fc9
20000a7c:	3c162fc9 	.word	0x3c162fc9

20000a80 <___osc_bl_saw_idx_veneer>:
20000a80:	f85f f000 	ldr.w	pc, [pc]	; 20000a84 <___osc_bl_saw_idx_veneer+0x4>
20000a84:	0801eac9 	.word	0x0801eac9
